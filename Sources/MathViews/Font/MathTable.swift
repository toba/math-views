import CoreText
import Foundation

// MARK: - Plist Data Model

/// Typed representation of a companion `.plist` MATH table file.
/// Decoded once at font load time; eliminates all `[String: Any]` casts.
struct MathTableData: Decodable {
    let version: String
    let constants: [String: Int]
    let accents: [String: Int]
    let italic: [String: Int]
    let v_variants: [String: [String]]
    let h_variants: [String: [String]]
    let v_assembly: [String: AssemblyEntry]

    struct AssemblyEntry: Decodable {
        let italic: Int
        let parts: [PartEntry]
    }

    struct PartEntry: Decodable {
        let advance: Int
        let endConnector: Int
        let startConnector: Int
        let extender: Bool
        let glyph: String
    }
}

// MARK: - GlyphPart

/// One piece of an extensible glyph assembly (top cap, bottom cap, mid section, or extender).
/// Used by the typesetter to construct tall delimiters and radical signs from parts defined
/// in the font's OpenType MATH table.
struct GlyphPart {
    /// The glyph that represents this part.
    let glyph: CGGlyph

    /// Full advance width/height for this part, in the direction of the extension in points.
    let fullAdvance: CGFloat

    /// Advance width/height of the straight bar connector material at the beginning of the glyph in points.
    let startConnectorLength: CGFloat

    /// Advance width/height of the straight bar connector material at the end of the glyph in points.
    let endConnectorLength: CGFloat

    /// If this part is an extender. If set, the part can be skipped or repeated.
    let isExtender: Bool
}

// MARK: - FontMathTable

/// Provides access to OpenType MATH table metrics for a specific font and size.
///
/// The [OpenType MATH table](https://www.microsoft.com/typography/otspec/math.htm)
/// defines constants and glyph-level data that control mathematical typesetting:
/// fraction gaps, radical geometry, delimiter construction recipes, script positioning,
/// accent attachment points, and inter-element spacing.
///
/// Rather than parsing the binary MATH table at runtime, each bundled font ships with
/// a companion `.plist` file (generated by `mathfont.py`) containing all table data
/// as a property list. This class reads those plists and converts raw font-design-unit
/// values to points for the current font size.
///
/// The effect of each constant on rendered output is documented in
/// [Vieth's TUGboat article](http://www.tug.org/TUGboat/tb30-1/tb94vieth.pdf).
///
/// This class is internal to the library â€” external callers interact with ``FontInstance``
/// and ``MathFont`` instead.
final class FontMathTable {
    let mathFont: MathFont
    let fontSize: CGFloat
    let unitsPerEm: UInt
    private let data: MathTableData
    private let _graphicsFont: CGFont

    /// Target position in the variant list for display-style glyph selection (0.6 = 60%).
    private static let displayStyleVariantRatio = 0.6

    /// MU unit in points
    var muUnit: CGFloat { fontSize / 18 }

    func fontUnitsToPt(_ fontUnits: Int) -> CGFloat {
        CGFloat(fontUnits) * fontSize / CGFloat(unitsPerEm)
    }

    init(mathFont: MathFont, size: CGFloat, unitsPerEm: UInt) {
        self.mathFont = mathFont
        fontSize = size
        self.unitsPerEm = unitsPerEm
        data = mathFont.mathTableData()
        _graphicsFont = mathFont.graphicsFont()
    }

    private func glyphName(for glyph: CGGlyph) -> String {
        (_graphicsFont.name(for: glyph) as? String) ?? ""
    }

    private func glyph(named name: String) -> CGGlyph {
        _graphicsFont.getGlyphWithGlyphName(name: name as CFString)
    }

    func constantFromTable(_ name: String) -> CGFloat {
        guard let value = data.constants[name] else { return .zero }
        return fontUnitsToPt(value)
    }

    func percentFromTable(_ percentName: String) -> CGFloat {
        guard let value = data.constants[percentName] else { return .zero }
        return CGFloat(value) / 100
    }

    // MARK: - Fractions

    /// Math Font Metrics from the opentype specification

    var fractionNumeratorDisplayStyleShiftUp: CGFloat {
        constantFromTable("FractionNumeratorDisplayStyleShiftUp")
    }

    var fractionNumeratorShiftUp: CGFloat { constantFromTable("FractionNumeratorShiftUp") }
    var fractionDenominatorDisplayStyleShiftDown: CGFloat {
        constantFromTable("FractionDenominatorDisplayStyleShiftDown")
    }

    var fractionDenominatorShiftDown: CGFloat { constantFromTable("FractionDenominatorShiftDown") }
    var fractionNumeratorDisplayStyleGapMin: CGFloat {
        constantFromTable("FractionNumDisplayStyleGapMin")
    }

    var fractionNumeratorGapMin: CGFloat { constantFromTable("FractionNumeratorGapMin") }
    var fractionDenominatorDisplayStyleGapMin: CGFloat {
        constantFromTable("FractionDenomDisplayStyleGapMin")
    }

    var fractionDenominatorGapMin: CGFloat { constantFromTable("FractionDenominatorGapMin") }
    var fractionRuleThickness: CGFloat { constantFromTable("FractionRuleThickness") }
    var skewedFractionHorizontalGap: CGFloat { constantFromTable("SkewedFractionHorizontalGap") }
    var skewedFractionVerticalGap: CGFloat { constantFromTable("SkewedFractionVerticalGap") }

    // MARK: - Non-standard

    /// Non-standard multiplier for fraction delimiter height (text style).
    private static let fractionDelimiterMultiplier: CGFloat = 1.01
    /// Non-standard multiplier for fraction delimiter height (display style).
    private static let fractionDelimiterDisplayMultiplier: CGFloat = 2.39

    var fractionDelimiterSize: CGFloat { Self.fractionDelimiterMultiplier * fontSize }
    var fractionDelimiterDisplayStyleSize: CGFloat {
        Self.fractionDelimiterDisplayMultiplier * fontSize
    }

    // MARK: - Stacks

    var stackTopDisplayStyleShiftUp: CGFloat { constantFromTable("StackTopDisplayStyleShiftUp") }
    var stackTopShiftUp: CGFloat { constantFromTable("StackTopShiftUp") }
    var stackDisplayStyleGapMin: CGFloat { constantFromTable("StackDisplayStyleGapMin") }
    var stackGapMin: CGFloat { constantFromTable("StackGapMin") }
    var stackBottomDisplayStyleShiftDown: CGFloat {
        constantFromTable("StackBottomDisplayStyleShiftDown")
    }

    var stackBottomShiftDown: CGFloat { constantFromTable("StackBottomShiftDown") }

    var stretchStackBottomShiftDown: CGFloat { constantFromTable("StretchStackBottomShiftDown") }
    var stretchStackGapAboveMin: CGFloat { constantFromTable("StretchStackGapAboveMin") }
    var stretchStackGapBelowMin: CGFloat { constantFromTable("StretchStackGapBelowMin") }
    var stretchStackTopShiftUp: CGFloat { constantFromTable("StretchStackTopShiftUp") }

    // MARK: - super/sub scripts

    var superscriptShiftUp: CGFloat { constantFromTable("SuperscriptShiftUp") }
    var superscriptShiftUpCramped: CGFloat { constantFromTable("SuperscriptShiftUpCramped") }
    var subscriptShiftDown: CGFloat { constantFromTable("SubscriptShiftDown") }
    var superscriptBaselineDropMax: CGFloat { constantFromTable("SuperscriptBaselineDropMax") }
    var subscriptBaselineDropMin: CGFloat { constantFromTable("SubscriptBaselineDropMin") }
    var superscriptBottomMin: CGFloat { constantFromTable("SuperscriptBottomMin") }
    var subscriptTopMax: CGFloat { constantFromTable("SubscriptTopMax") }
    var subSuperscriptGapMin: CGFloat { constantFromTable("SubSuperscriptGapMin") }
    var superscriptBottomMaxWithSubscript: CGFloat {
        constantFromTable("SuperscriptBottomMaxWithSubscript")
    }

    var spaceAfterScript: CGFloat { constantFromTable("SpaceAfterScript") }

    // MARK: - radicals

    var radicalExtraAscender: CGFloat { constantFromTable("RadicalExtraAscender") }
    var radicalRuleThickness: CGFloat { constantFromTable("RadicalRuleThickness") }
    var radicalDisplayStyleVerticalGap: CGFloat {
        constantFromTable("RadicalDisplayStyleVerticalGap")
    }

    var radicalVerticalGap: CGFloat { constantFromTable("RadicalVerticalGap") }
    var radicalKernBeforeDegree: CGFloat { constantFromTable("RadicalKernBeforeDegree") }
    var radicalKernAfterDegree: CGFloat { constantFromTable("RadicalKernAfterDegree") }
    var radicalDegreeBottomRaisePercent: CGFloat {
        percentFromTable("RadicalDegreeBottomRaisePercent")
    }

    // MARK: - Limits

    var upperLimitBaselineRiseMin: CGFloat { constantFromTable("UpperLimitBaselineRiseMin") }
    var upperLimitGapMin: CGFloat { constantFromTable("UpperLimitGapMin") }
    var lowerLimitGapMin: CGFloat { constantFromTable("LowerLimitGapMin") }
    var lowerLimitBaselineDropMin: CGFloat { constantFromTable("LowerLimitBaselineDropMin") }
    var limitExtraAscenderDescender: CGFloat { 0 }

    // MARK: - Underline

    var underbarVerticalGap: CGFloat { constantFromTable("UnderbarVerticalGap") }
    var underbarRuleThickness: CGFloat { constantFromTable("UnderbarRuleThickness") }
    var underbarExtraDescender: CGFloat { constantFromTable("UnderbarExtraDescender") }

    // MARK: - Overline

    var overbarVerticalGap: CGFloat { constantFromTable("OverbarVerticalGap") }
    var overbarRuleThickness: CGFloat { constantFromTable("OverbarRuleThickness") }
    var overbarExtraAscender: CGFloat { constantFromTable("OverbarExtraAscender") }

    // MARK: - Constants

    var axisHeight: CGFloat { constantFromTable("AxisHeight") }
    var scriptScaleDown: CGFloat { percentFromTable("ScriptPercentScaleDown") }
    var scriptScriptScaleDown: CGFloat { percentFromTable("ScriptScriptPercentScaleDown") }
    var mathLeading: CGFloat { constantFromTable("MathLeading") }
    var delimitedSubFormulaMinHeight: CGFloat { constantFromTable("DelimitedSubFormulaMinHeight") }

    // MARK: - Accent

    var accentBaseHeight: CGFloat { constantFromTable("AccentBaseHeight") }
    var flattenedAccentBaseHeight: CGFloat { constantFromTable("FlattenedAccentBaseHeight") }

    // MARK: - Variants

    /// Returns an Array of all the vertical variants of the glyph if any. If
    /// there are no variants for the glyph, the array contains the given glyph.
    func verticalVariants(for glyph: CGGlyph) -> [CGGlyph] {
        variants(for: glyph, in: data.v_variants)
    }

    /// Returns an Array of all the horizontal variants of the glyph if any. If
    /// there are no variants for the glyph, the array contains the given glyph.
    func horizontalVariants(for glyph: CGGlyph) -> [CGGlyph] {
        variants(for: glyph, in: data.h_variants)
    }

    func variants(for glyph: CGGlyph, in variants: [String: [String]]) -> [CGGlyph] {
        let name = glyphName(for: glyph)

        guard let variantGlyphs = variants[name], !variantGlyphs.isEmpty else {
            let glyph = self.glyph(named: name)
            return [glyph]
        }
        var glyphArray = [CGGlyph]()
        for glyphVariantName in variantGlyphs {
            let variantGlyph = self.glyph(named: glyphVariantName)
            glyphArray.append(variantGlyph)
        }
        return glyphArray
    }

    /// Returns a larger vertical variant of the given glyph if any.
    /// If there is no larger version, this returns the current glyph.
    ///
    /// - Parameter glyph: The glyph to find a larger variant for
    /// - Parameter forDisplayStyle: If true, selects the largest appropriate variant for display style.
    ///                             If false, selects the next larger variant (incremental sizing).
    /// - Returns: A larger glyph variant, or the original glyph if no variants exist
    func largerGlyph(_ glyph: CGGlyph, displayStyle: Bool = false) -> CGGlyph {
        let name = glyphName(for: glyph)

        guard let variantGlyphs = data.v_variants[name], !variantGlyphs.isEmpty else {
            return glyph
        }

        if displayStyle {
            let count = variantGlyphs.count
            let targetIndex: Int

            if count <= 2 {
                targetIndex = count - 1
            } else if count <= 4 {
                targetIndex = count - 2
            } else {
                // Pick a variant ~60% through the list for display style
                targetIndex = min(count - 2, Int(Double(count) * Self.displayStyleVariantRatio))
            }

            let glyphVariantName = variantGlyphs[targetIndex]
            return self.glyph(named: glyphVariantName)
        } else {
            for glyphVariantName in variantGlyphs where glyphVariantName != name {
                return self.glyph(named: glyphVariantName)
            }
        }

        return glyph
    }

    // MARK: - Italic Correction

    /// Returns the italic correction for the given glyph if any. If there
    /// isn't any this returns 0.
    func italicCorrection(for glyph: CGGlyph) -> CGFloat {
        let name = glyphName(for: glyph)
        guard let value = data.italic[name] else { return .zero }
        return fontUnitsToPt(value)
    }

    // MARK: - Accents

    /// Returns the adjustment to the top accent for the given glyph if any.
    /// If there isn't any this returns the center of the advance width.
    func topAccentAdjustment(for glyph: CGGlyph) -> CGFloat {
        let name = glyphName(for: glyph)

        guard let value = data.accents[name] else {
            var glyph = glyph
            var advances = CGSize.zero
            let ctFont = mathFont.coreTextFont(size: fontSize)
            CTFontGetAdvancesForGlyphs(ctFont, .horizontal, &glyph, &advances, 1)
            return advances.width / 2
        }
        return fontUnitsToPt(value)
    }

    // MARK: - Glyph Construction

    /// Minimum overlap of connecting glyphs during glyph construction
    var minConnectorOverlap: CGFloat { constantFromTable("MinConnectorOverlap") }

    /// Returns an array of the glyph parts to be used for constructing vertical variants
    /// of this glyph. If there is no glyph assembly defined, returns an empty array.
    func verticalGlyphAssembly(for glyph: CGGlyph) -> [GlyphPart] {
        let name = glyphName(for: glyph)

        guard let entry = data.v_assembly[name] else { return [] }

        var parts = [GlyphPart]()
        for partEntry in entry.parts {
            let partGlyph = self.glyph(named: partEntry.glyph)
            let part = GlyphPart(
                glyph: partGlyph,
                fullAdvance: fontUnitsToPt(partEntry.advance),
                startConnectorLength: fontUnitsToPt(partEntry.startConnector),
                endConnectorLength: fontUnitsToPt(partEntry.endConnector),
                isExtender: partEntry.extender,
            )
            parts.append(part)
        }
        return parts
    }
}
